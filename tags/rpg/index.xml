<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rpg on PY-&gt; Blog</title>
    <link>/tags/rpg/</link>
    <description>Recent content in Rpg on PY-&gt; Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>us-en</language>
    <lastBuildDate>Wed, 22 Aug 2018 14:25:14 +0800</lastBuildDate>
    
	<atom:link href="/tags/rpg/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>常用设计模式——游戏框架-02</title>
      <link>/post/game-frame-02/</link>
      <pubDate>Wed, 22 Aug 2018 14:25:14 +0800</pubDate>
      
      <guid>/post/game-frame-02/</guid>
      <description>设计模式 单例模式  单例模式：在软件生命周期，有且只有一个实例（不占内存空间）。
1 2 3 4 5 6 7 8 9  //class 抽象概念 //每new一个（实例化）就会占用一块内存 //相互没有关联  //如果是单例，就可以省去麻烦 public static Instance; //以static const修饰为全局变量,只会实例化一次 static const _Instance;    有两种方式：
 继承MonoBehaviour：拖拽挂载脚本相当于new，一般用在组织框架（模块）的管理器上。 非继承：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //非继承MonoBehaviour通用写法  public class TestSingl { private static TestSingl instance; public static TestSingl Instance { get { if(instamce == null) instamce = new TestSingl(); return instance; } } }   工厂模式  工厂模式：交给工厂一个任务，就会产出一个产品，无需关心生产过程。</description>
    </item>
    
    <item>
      <title>设计原则——游戏框架-01</title>
      <link>/post/game-frame-01/</link>
      <pubDate>Mon, 13 Aug 2018 21:05:01 +0800</pubDate>
      
      <guid>/post/game-frame-01/</guid>
      <description>设计原则   注意   适应变化（有层次感；有变更，代码改动小） 提高代码重用率（封装调用） 可维护性（） 可扩展性   框架  总结把所有类型游戏共用方法封装，随时调用。
涉及 图形学 opengl，工程学，算法。
 原则   单一原则：就负责一件事，模块化，分开，提高效率
 开闭原则：一个实体（类，函数，模块等）应该对外扩展开放，对内修改关闭。
  每次发生变化，通过添加新的代码来增强现有类型的行为，而不是修改原有代码。
1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class program(){ age = 10; public intAge { get{} set{} } //或者  public void GetAge(Int tempAge) { this.age = tempAge; } }    依赖倒置原则：指的是抽象不应依赖于细节，也就是提出“面向接口编程，而不是面向实现编程”，可以降低客户与具体实现的耦合  1.</description>
    </item>
    
  </channel>
</rss>