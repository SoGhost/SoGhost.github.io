<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PY-&gt; Blog</title>
    <link>/</link>
    <description>Recent content on PY-&gt; Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>us-en</language>
    <lastBuildDate>Mon, 17 Sep 2018 08:58:13 +0800</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>角色模块封装——游戏框架-08</title>
      <link>/post/game-frame-08/</link>
      <pubDate>Mon, 17 Sep 2018 08:58:13 +0800</pubDate>
      
      <guid>/post/game-frame-08/</guid>
      <description>Role（角色基类）：
 FSM
 CharactorController
   玩家：
 EasyTouch 控制移动和旋转
 矩形攻击&amp;hellip;
  NPC：
 AI 攻击    NPCManager管理NPC。</description>
    </item>
    
    <item>
      <title>2D攻击范围</title>
      <link>/post/2d-attack-range/</link>
      <pubDate>Sun, 09 Sep 2018 16:15:05 +0800</pubDate>
      
      <guid>/post/2d-attack-range/</guid>
      <description>攻击范围判断：
 物理触发器：极其消耗性能，休闲类可以使用物理触发器，大型游戏不可以。
 向量点乘(Vector3.Dot)：
 A · B = |A| * |B| * cosθ |A|就是A向量长度    假如 A 是单位向量 |A| = 1 得到 B 在 A 向量上的投影。 假如 A 和 B 都是单位向量得到 cosθ arcos(A, B) 得到一个弧度。   将被攻击者坐标系变换到攻击者坐标系，在进行 x, z点位置判断
  矩形攻击：
transform.forward：表示Player的正前方（forward和right均为单位向量）
transform.right：表示Player的正右方
-transform.right：表示Player的正左方
-transform.forward：表示Player的正后方
A = Enemy.position - Player.position（玩家与敌人的距离是A）
  yLength = A · transform.forward：等于A在forward线上的投影，yLength也是矩形的宽度y  A · transform.forward = |A| * cosθ, cosθ范围 (θ：π/2 ~ -π/2 = 0~180°) 从正数到负数（判断上下方向）。 如果A是正数说明在前方，负数为后方（得到敌人在前或后的哪个方向，在进行下一步判断） 如果yLength大于矩形的宽度说明不在范围内（小于矩形的宽度也不一定在范围内）。  xLength = A · transform.</description>
    </item>
    
    <item>
      <title>有限状态机</title>
      <link>/post/finite-state-machine/</link>
      <pubDate>Sun, 09 Sep 2018 09:16:19 +0800</pubDate>
      
      <guid>/post/finite-state-machine/</guid>
      <description>有限状态机（Finite-state machine，FSM）：
 又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。
 动画控制器控制多个状态，用于实现两个状态之间的跳转。 0  动画分成：动画控制层、位移控制层、数据层、逻辑控制层。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320  &amp;gt; // 示例 FSM &amp;gt; /// &amp;lt;summary&amp;gt; &amp;gt; /// 状态共同的特性，抽象为一个基类 &amp;gt; /// &amp;lt;/summary&amp;gt; &amp;gt; public class FSMBase &amp;gt; { &amp;gt; public virtual void OnEnter() &amp;gt; {} &amp;gt; public virtual void OnStay() &amp;gt; {} &amp;gt; public virtual void OnExit() &amp;gt; {} &amp;gt; } &amp;gt; &amp;gt; /// &amp;lt;summary&amp;gt; &amp;gt; /// 管理多个FSMBase &amp;gt; /// &amp;lt;/summary&amp;gt; &amp;gt; public class FSMManager &amp;gt; { &amp;gt; //数组存储所有状态 &amp;gt; FSMBase[] allState; &amp;gt; &amp;gt; #region Initial &amp;gt; &amp;gt; // #region (Name) &amp;gt; // #endregion，可以折叠中段代码 &amp;gt; //进一步封装初始化，构造函数 &amp;gt; public FSMManager(int stateCount) &amp;gt; { &amp;gt; Initial(stateCount); &amp;gt; } &amp;gt; &amp;gt; //初始化封装 &amp;gt; public void Initial(int stateCount) &amp;gt; { &amp;gt; allState = new FSMBase[stateCount]; &amp;gt; } &amp;gt; &amp;gt; #endregion &amp;gt; &amp;gt; // byte 范围（0~255），节省内存，用于表示状态数足够了 &amp;gt; // sbyte 可以带符号 标记 &amp;gt; sbyte curState = -1;//表示当前存储了多少状态 &amp;gt; &amp;gt; sbyte stateIndex = -1;//表示当前处于状态 &amp;gt; &amp;gt; //添加状态 &amp;gt; public void AddState(FSMBase tmpBase) &amp;gt; { &amp;gt; //防止越界 &amp;gt; if (curState &amp;gt; allState.</description>
    </item>
    
    <item>
      <title>GL画图功能</title>
      <link>/post/gl-drawing/</link>
      <pubDate>Sat, 08 Sep 2018 09:43:45 +0800</pubDate>
      
      <guid>/post/gl-drawing/</guid>
      <description>画图：  鼠标（或触摸）画出的图形显示在屏幕上
 获取鼠标（或触摸）的坐标
 记录鼠标（或触摸）在屏幕的比例
   世界坐标系：以(0, 0)坐标为原点，记录的相对位置。
物体坐标系(Local Position)：以父类坐标为参考，记录的相对位置。
相机坐标系：以相机坐标为参考，记录的相对位置。
视图坐标系：坐标系x y范围为(0 ~ 1)，记录比例。
屏幕坐标系(Input.mousePosition)：原点（左下角）：(0, 0) 右上角：(屏幕分辨率宽, 屏幕分辨率高)。
 在屏幕上画图
 Line Renderer OpenGL（Open Graphics Library）  屏幕上画的图形显示到图片或者3D物体上（旗帜、布）
 截屏：ScreenCapture.CaptureScreenshot() 点在图片上画：根据顶点坐标设置像素位置  图形映射到物体：用新建Texture2D存储图片，再替换修改纹理。
 2D：替换Image的Sprite   transform.GetComponent().sprite = Sprite.Create(texture2D, new Rect(0, 0, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f));
  3D：替换Render里的Texture   transform.GetComponent().material.mainTexture = texture2D;
   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179  using System.</description>
    </item>
    
    <item>
      <title>小地图封装——游戏框架-07</title>
      <link>/post/game-frame-07/</link>
      <pubDate>Sat, 08 Sep 2018 07:59:20 +0800</pubDate>
      
      <guid>/post/game-frame-07/</guid>
      <description>小地图(mini-map)&amp;mdash;DEMO：  两个相机（消耗性能）
 (3D&amp;ndash;&amp;gt;2D)等比例映射： 控制的物体位置实时映射到地图上的图片中
 求出物体与地图的比例：Player位置 - 地形位置 = Player相对于地形的位置 = tmpPos tmpPos.x / 地形宽度 = x比例 tmpPos.z / 地形长度 = y比例 (地图背景图片 * x比例, 地图背景图片 * y比例) = 地图里Player图片的位置   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  using UnityEngine; /// &amp;lt;summary&amp;gt; /// 1.</description>
    </item>
    
    <item>
      <title>EasyTouch模块封装——游戏框架-06</title>
      <link>/post/game-frame-06/</link>
      <pubDate>Fri, 07 Sep 2018 18:18:05 +0800</pubDate>
      
      <guid>/post/game-frame-06/</guid>
      <description>EasyTouch 制作流程：  获取鼠标到圆心的半径 &amp;gt;deltaDistance = 鼠标点 &amp;ndash; 圆心 &amp;ndash;&amp;gt; 判断距离
 移动范围
 在圆内可以任意移动   deltaDistance.magnitude&amp;lt; 半径（deltaDistance.magnitude = Vector2.Distance()，求两向量间距离）
  超过半径只能在圆上移动    实现物体跟着旋转
 让图片随着摇杆移动旋转
 切线：Z = Tan α &amp;ndash;&amp;gt; Q = ArcTan z（Q 弧度） 弧度：π = 180° π / 2 = 3.1415926 / 2 ≈ 1.57 = 90° 角度：180° = π  摇杆原点随着摇杆移动变化
 1    测试简单 EasyTouch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  using UnityEngine; using UnityEngine.</description>
    </item>
    
    <item>
      <title>UI模块封装——游戏框架-05</title>
      <link>/post/game-frame-05/</link>
      <pubDate>Fri, 31 Aug 2018 17:52:54 +0800</pubDate>
      
      <guid>/post/game-frame-05/</guid>
      <description>UI模块  UI 流程：  拼出大致UI效果图 UI小图片 &amp;mdash;&amp;gt; TexturePacker打包图集 （.png有A通道，.jpg没有） &amp;mdash;&amp;gt; Unity下载TexturePacker的导入插件 拼UI： 新建Canves &amp;mdash;&amp;gt; 新建Panel （背景设为UI效果图，照着拼，以Panel为单位，一个Panel一个界面） &amp;mdash;&amp;gt; 划分UI层级 写代码： ↓↓↓↓       MVC模式（Model–view–controller）     模型（Model） 数据模型（数据结构，username、password）。用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。   视图（View） 能够实现数据有目的的显示（理论上，这不是必需的）。   控制器（Controller） 逻辑控制层。起到不同层面间的组织作用，用于控制应用程序的流程。它处理事件并作出响应。“事件”包括用户的行为和数据 Model 上的改变。     控制器（Controller）：由UIManager管理所有Panel，由PanelManager管理所有子控件。
 子控件发生事件让其主动’上报‘，所以给需要的控件添加UIBehaviour脚本。 UIBehaviour会将自己注册到UIManager。 UIManager：保存注册到UIManager里的子控件。  销毁：
 将后面还用到的界面隐藏（背包界面，菜单界面） 将后面用不到的界面Destory（登录界面）  资源的加载：
 Loading界面 还会加载后面要用的资源到内存（Resources.Load），不实例化。用到时GameObject.Instantiate将内存中资源实例化到场景中。 进入二级Loading界面会将前面的资源卸载，加载后面的资源。   注意事项：   在同一个Panel里要使用的控件的名字不能一样！</description>
    </item>
    
    <item>
      <title>音效模块封装——游戏框架-04</title>
      <link>/post/game-frame-04/</link>
      <pubDate>Thu, 30 Aug 2018 07:19:04 +0800</pubDate>
      
      <guid>/post/game-frame-04/</guid>
      <description>音效模块  Audio Manager（音效管理）管理Source Manager和Clips Manager，Source Manager管理多个AudioSource，Clips Manager管理多个AudioClips。
   抽象AudioSource： 抽象AudioClips：     1. 能够从所有的AudioSource中拿出一个空闲的AudioSource 1. 根据名字找出对应的Clips   2. 释放多余的（空闲的）AudioSource 2. 通过配置文件读取名字   3. 播放一个音效 3. 加载到内存   4. 停止播放     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298  using System.</description>
    </item>
    
    <item>
      <title>http WWW封装——游戏框架-03</title>
      <link>/post/game-frame-03/</link>
      <pubDate>Wed, 29 Aug 2018 15:15:31 +0800</pubDate>
      
      <guid>/post/game-frame-03/</guid>
      <description>WWW类  WWW：
 http请求：超文本协议，点击一次，请求一次数据，返回一个数据（json、xml、protbuffer&amp;hellip;）。
 Get请求：参数在连接里面，链接的 ？、# 或其他符号后都是参数。 Post请求：参数在表单里面，服务器在底层看见Post请求，会自动分配一个大空间（传输大文件）。  WWW下载本地文件：根据不同平台，有不同前缀
 IOS：http://, https:// and file:// Android：jar:file:// PC：File:///   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118  using System.</description>
    </item>
    
    <item>
      <title>常用设计模式——游戏框架-02</title>
      <link>/post/game-frame-02/</link>
      <pubDate>Wed, 22 Aug 2018 14:25:14 +0800</pubDate>
      
      <guid>/post/game-frame-02/</guid>
      <description>设计模式 单例模式  单例模式：在软件生命周期，有且只有一个实例（不占内存空间）。
1 2 3 4 5 6 7 8 9  //class 抽象概念 //每new一个（实例化）就会占用一块内存 //相互没有关联  //如果是单例，就可以省去麻烦 public static Instance; //以static const修饰为全局变量,只会实例化一次 static const _Instance;    有两种方式：
 继承MonoBehaviour：拖拽挂载脚本相当于new，一般用在组织框架（模块）的管理器上。 非继承：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //非继承MonoBehaviour通用写法  public class TestSingl { private static TestSingl instance; public static TestSingl Instance { get { if(instamce == null) instamce = new TestSingl(); return instance; } } }   工厂模式  工厂模式：交给工厂一个任务，就会产出一个产品，无需关心生产过程。</description>
    </item>
    
    <item>
      <title>English Sentence</title>
      <link>/post/english-sentence-01/</link>
      <pubDate>Tue, 14 Aug 2018 08:35:36 +0800</pubDate>
      
      <guid>/post/english-sentence-01/</guid>
      <description>tutorial 辅导 &amp;gt;I made a tutorial on ways you can go about making a melon combat system with unity and c-sharp and so i thought i only normal to fallow up with a ranged combat video by the end of this tutorial you&amp;rsquo;ll have a character capable of handling a ranged weapon that rotates to face the mouse cursor and then shoots cool looking arrows that kill enemies of course you&amp;rsquo;ll be able to a plan you learn during this video to make all kinds of range shooting systems from huge powerful bullets and rockets to delicate little arrows now everything taugh here can be applied to any game in need for a shooting system without a child i&amp;rsquo;m sure or a side-scorlling platformer so as you can see i&amp;rsquo;ve set up this little seam with an archer like character who carries a simple ranged weapon and i can move left and right i also got an enemy character i&amp;rsquo;ll use has targets.</description>
    </item>
    
    <item>
      <title>设计原则——游戏框架-01</title>
      <link>/post/game-frame-01/</link>
      <pubDate>Mon, 13 Aug 2018 21:05:01 +0800</pubDate>
      
      <guid>/post/game-frame-01/</guid>
      <description>设计原则   注意   适应变化（有层次感；有变更，代码改动小） 提高代码重用率（封装调用） 可维护性（） 可扩展性   框架  总结把所有类型游戏共用方法封装，随时调用。
涉及 图形学 opengl，工程学，算法。
 原则   单一原则：就负责一件事，模块化，分开，提高效率
 开闭原则：一个实体（类，函数，模块等）应该对外扩展开放，对内修改关闭。
  每次发生变化，通过添加新的代码来增强现有类型的行为，而不是修改原有代码。
1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class program(){ age = 10; public intAge { get{} set{} } //或者  public void GetAge(Int tempAge) { this.age = tempAge; } }    依赖倒置原则：指的是抽象不应依赖于细节，也就是提出“面向接口编程，而不是面向实现编程”，可以降低客户与具体实现的耦合  1.</description>
    </item>
    
    <item>
      <title>UI 特效制作</title>
      <link>/post/ui-effects-01/</link>
      <pubDate>Mon, 13 Aug 2018 19:05:36 +0800</pubDate>
      
      <guid>/post/ui-effects-01/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Unity Tilemap模块</title>
      <link>/post/unity-tilemap_mod/</link>
      <pubDate>Mon, 13 Aug 2018 08:47:21 +0800</pubDate>
      
      <guid>/post/unity-tilemap_mod/</guid>
      <description>TileMap(瓦片地图)： &amp;gt;可以快速构建关卡，也可以通过相关API代码生成。
 相关组件
  Grid:格子相关属性，TileMap是它子，也是一种画布（Canvas）。
  TileMap:接收绘制好瓦片的地方，类似PS图层。
  TileMap Renderer:控制瓦片渲染效果的组件，比如渲染顺序、遮罩、材质等。
  Tile Palette:控制瓦片中间层，这里选择需要的瓦片。
  Tile:瓦片，里面存储一个Sprite的引用和一个颜色值和碰撞类型。
  2D - extras:TileMap的2D官方拓展包，有拓展笔刷和瓦片
https://github.com/Unity-Technologies/2d-extras
    使用TileMap快速构建关卡
 使用RuleTile
  3.Cinemachine在2D中使用方法</description>
    </item>
    
    <item>
      <title>网络知识——P2P</title>
      <link>/post/computer-illiteracy-p2p/</link>
      <pubDate>Sat, 11 Aug 2018 17:14:14 +0800</pubDate>
      
      <guid>/post/computer-illiteracy-p2p/</guid>
      <description></description>
    </item>
    
    <item>
      <title>【Pain To Learn Unity】——案例之像素鸟</title>
      <link>/post/pain-to-learn-unity-notes-01/</link>
      <pubDate>Sat, 11 Aug 2018 15:08:23 +0800</pubDate>
      
      <guid>/post/pain-to-learn-unity-notes-01/</guid>
      <description> 下载.Zip
下载.unitypacke
创建UI界面 创建开始菜单界面   创建button的图片，按住shift——等比缩放，再加入button组件。
 创建静音Toggle，背景图设为启动音量图片，前景设为斜线（静音），删除无用文字，关闭Toggle的Is On，即可实现初始不显示前景，点击后显示前景图片。
   添加点击事件  首先把菜单所有元素（除了背景）放到一个空物体上，控制空物体Enable达到切换场景目的。
 然后调整一下UI元素锚点（Anchor Presets）的大致位置。（锚点用于自动适配分辨率，自动调整UI位置）
    ra   </description>
    </item>
    
    <item>
      <title>【Pain To Learn Unity】——案例之吃豆人</title>
      <link>/post/pain-to-learn-unity-notes-02/</link>
      <pubDate>Sat, 11 Aug 2018 15:08:23 +0800</pubDate>
      
      <guid>/post/pain-to-learn-unity-notes-02/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Unity 动画系统（4）</title>
      <link>/post/unity-animation-system-04/</link>
      <pubDate>Thu, 09 Aug 2018 14:57:50 +0800</pubDate>
      
      <guid>/post/unity-animation-system-04/</guid>
      <description> Animation Controller </description>
    </item>
    
    <item>
      <title>Unity 动画系统（3）</title>
      <link>/post/unity-animation-system-03/</link>
      <pubDate>Thu, 09 Aug 2018 12:47:45 +0800</pubDate>
      
      <guid>/post/unity-animation-system-03/</guid>
      <description>Animation View  Animation View可以修改的类型：Float, Color, Vector2, Vector3, Vector4, Quaternion, Boolean.
 Add Key:添加特征点 Add Event:添加事件系统    Add Property：增加动画变换属性   可以给给所有物体添加动画。（制作摄像机抖动）
  Root Motion   选中后该物体会相对于（目标）物体坐标移动，否则相对于世界坐标移动。    Animation Event &amp;gt;方便实现角色着陆音效与运动镜头抖动。
 可执行函数 &amp;gt;1. 必须为Public &amp;gt; &amp;gt;2. 函数返回为Void &amp;gt; &amp;gt;3. 只有一个参数 &amp;gt; &amp;gt;4. 输入参数类型包括：int, float, string, Object &amp;gt; &amp;gt; ```c# &amp;gt; public class testAnimationEvent : MonoBehaviour{
public void testPrintLog(float msg){ Debug.Log(&amp;ldquo;Animation Event: &amp;ldquo; + msg.</description>
    </item>
    
    <item>
      <title>Unity 动画系统（2）</title>
      <link>/post/unity-animation-system-02/</link>
      <pubDate>Wed, 08 Aug 2018 20:19:02 +0800</pubDate>
      
      <guid>/post/unity-animation-system-02/</guid>
      <description> 模型创建  Modelling 建模 &amp;gt;Unity以米为单位（一单位长度）。
 Rigging 绑定骨骼 &amp;gt;最少有15个关节，遵循拓扑结构
 Skinning 蒙皮
  模型导入  通用文件导入（.fbx，.obj，.3DS，.dfx，.dea）   .fbx：存储骨骼和动画
通用文件比较节省资源
  原始模型导入（.MAX，.MB，.Blend，.MA）   不过需要预装对应软件
方便，但浪费较大空间
 模型配置    Model rig Animations     Scale Factor(比例系数) Animation Type(骨骼状态)    Mesh Compression(网格压缩)     Generate Lightmap(生成光照贴图)      创建动画 </description>
    </item>
    
    <item>
      <title>UGUI</title>
      <link>/post/ugui-01/</link>
      <pubDate>Wed, 08 Aug 2018 13:34:19 +0800</pubDate>
      
      <guid>/post/ugui-01/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Unity 动画系统（1）</title>
      <link>/post/unity-animation-system-01/</link>
      <pubDate>Mon, 06 Aug 2018 11:45:28 +0800</pubDate>
      
      <guid>/post/unity-animation-system-01/</guid>
      <description>Mecanim——核心功能  内置动画状态机系统(Animator)      Controller 角色控制器     Avatar (骨骼替身) 替身骨骼   Apply Root Motion ( 应用根运动 )    Update Mode ( 刷新模式 )    Culling Mode (选择模式)       人物动画的重定向   更换的Avatar即可重复使用动画。
1.在Model 选取界面，选择 RIG&amp;ndash;&amp;gt;Animation Type-&amp;gt;Humanoid(人形的)-&amp;gt;Apply
2.然后可以配置人物骨骼Avatar。
  动画的分解与混合   Blend Tree：混合树
通过Blend Tree混合多个动画。
通过添加其他动画同时播放多个动画。
  关节动画的 IK 逆向定位   IK用于实现角色始终看着一个物体、一个关节与物体绑定。</description>
    </item>
    
    <item>
      <title>JSON格式</title>
      <link>/post/json/</link>
      <pubDate>Mon, 06 Aug 2018 07:42:20 +0800</pubDate>
      
      <guid>/post/json/</guid>
      <description>JSON简介  JSON：是一种轻量级的数据交换格式。基于JavaScript的一个子集。JSON采用完全独立于语言的文本格式。Unity主要使用JSON进行服务器端和客户端数据传输。
 JSON结构  通过对象、数组两种结构，就可以组成复杂的数据结构。
  JSON对象   对象：表示为 ‘ {} ’ 括起来的内容，数据结果为键值对的结构。
{ &amp;ldquo;name&amp;rdquo; : &amp;ldquo;Test Name&amp;rdquo; }
属性可以为 数字、字符串、数组、对象。
  JSON数组   数组：中括号 &amp;lsquo; [ ] &amp;lsquo; 括起来的内容，数据结构为 [ &amp;ldquo;C#&amp;rdquo;, &amp;ldquo;Unity&amp;rdquo;, &amp;hellip;] ，取值方式和所有语言一样，使用索引获取，字段值的类型可以是 数字、字符串、数组、对象。
  JSON示例  1 2 3 4 5 6 7 8 9  //Json对象 { &amp;#34;name&amp;#34;:&amp;#34;Ted&amp;#34;, &amp;#34;Lv&amp;#34;:1, &amp;#34;Job&amp;#34;:&amp;#34;法师&amp;#34;, &amp;#34;Exp&amp;#34;:1.1 } //复杂Json对象 { &amp;#34;name&amp;#34;:&amp;#34;Jack&amp;#34;, &amp;#34;info&amp;#34;:{ &amp;#34;Lv&amp;#34;:2, &amp;#34;Job&amp;#34;:&amp;#34;战士&amp;#34;, &amp;#34;Exp&amp;#34;:2.</description>
    </item>
    
    <item>
      <title>AI逻辑</title>
      <link>/post/unity-ai-01/</link>
      <pubDate>Sun, 05 Aug 2018 18:36:56 +0800</pubDate>
      
      <guid>/post/unity-ai-01/</guid>
      <description>AI  Navigation   给Enemy添加 New Mesh Agent。
 Acceleration：加速度 Angular Speed：转向速度    常用方法
 SetDestination(player_position);   添加寻找对象。
  AI 逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  using UnityEngine; using System.</description>
    </item>
    
    <item>
      <title>游戏常用英文</title>
      <link>/post/game-words/</link>
      <pubDate>Sun, 05 Aug 2018 14:48:59 +0800</pubDate>
      
      <guid>/post/game-words/</guid>
      <description>常见单词 1.角色属性类：  角色 Character 力量 Strength 耐力 Stamina/Patience 智力 Intellect 免疫力 Immune/Immunity 生命力 Hit Point(HP) 魔法力 Magic Point(MP) 命中率 Accuracy 速度 speed 防御 Defense 敏锐 Subtlety 伤害 Damage 护甲 Armor 能量 power 危险 danger 安全 safety 经验点数 Experience Point 升级 Level Up
 2.技能效果类：  技能 skill 净化 Cleansing 复活 Reincarnate 石化 Petrify 灼烧 Cauterize 重击 Smite 伪装 Camouflage 致盲 Blind 背刺 Backstab 埋伏 Ambush 吸魔 Drain Mana 吸血 Drain Life 躲避 Miss 守护 Guard 隐形 Clock 祝福 Blessed 加血 add blood 持续时间 Duration</description>
    </item>
    
    <item>
      <title>FPS_视角和移动</title>
      <link>/post/unity-fps-view_move/</link>
      <pubDate>Sun, 05 Aug 2018 14:48:37 +0800</pubDate>
      
      <guid>/post/unity-fps-view_move/</guid>
      <description>主要涉及知识  1、Input.GetAxis(“Mouse X”)：获取鼠标延左右移动的速度 2、Input.GetAxis(“Mouse Y”)：获取鼠标延上下移动的速度 3、Input.GetKeyDown(“escape”)：按下esc键 4、transform.Rotate()：使物体旋转，如果最后一个参数relativeTo默认以局部坐标旋转，如果设置为-Space.World（世界坐标系），则旋转应用于世界x，y，z轴。 5、transform.localEulerAngles：物体的欧拉角（相对于父级的坐标），此例子我们直接改变物体的欧拉角以达到旋转的效果。和用transform.Rotate()改变有所区别 6、Mathf.Clamp()： 7、Cursor.lockState = CursorLockMode.Locked;将光标锁定到游戏窗口的中心。 Cursor.lockState = CursorLockMode.Confined;将光标限制在游戏窗口。 8、Cursor.visible = false;隐藏光标 9、CharacterController：CharacterController类。CharacterController允许你简单地做碰撞约束的移动，而不必处理刚体。 10、CharacterController.Move()：通过运动移动控制器，并且受碰撞约束，会延着碰撞体表面滑动，它不受重力影响。（相对于世界坐标系来移动物品） 11、transform.TransformDirection()：转换为世界坐标系 12、Vector3.ClampMagnitude()：限制一个向量的最大长度。  镜头跟随鼠标旋转 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  using UnityEngine; using System.</description>
    </item>
    
    <item>
      <title>Unity Audio</title>
      <link>/post/unity-audio-01/</link>
      <pubDate>Sun, 05 Aug 2018 09:39:51 +0800</pubDate>
      
      <guid>/post/unity-audio-01/</guid>
      <description> Audio Source  1.Audio Source
 Audio Clip：音频剪辑
 Output：输出
 Audio Mixer Group：音频混音器组
 Mute：静音
 Bypass Effectes：绕过效果
 Bypass Listener Effects：绕过监听器效果
 Bypass Reverb Zones：绕过混响区
 Play On Wake：开始时播放
 Loop：循环
 Priority：优先
 Volume：音量
 Pitch：
 Stereo Pan：
 Spatial Blend：空间混合
 Reverb Zone Mix：
  2.3D Sound Setting
 Doppler Level：多普勒级别 Spread：传播 Volume Rolloff： Min Distance：最小距离 Max Distance：最大距离   </description>
    </item>
    
    <item>
      <title>脚本的输入与控制</title>
      <link>/post/script-input_control/</link>
      <pubDate>Mon, 30 Jul 2018 16:36:45 +0800</pubDate>
      
      <guid>/post/script-input_control/</guid>
      <description>鼠标输入 1.OnMouse方法  OnMouseEnter()：当鼠标进入GUIElement或Collider时调用。（只调用一次）
OnMouseExit()：鼠标离开GUIElement或Collider时调用。
OnMouseOver()：鼠标悬停在GUIElement或Collider上时调用每一帧。
OnMouseDown()：鼠标在GUIElement或Collider上点击时调用。
OnMouseIp()：释放鼠标按钮时调用。
OnMouseDrag()：鼠标拖拽GUIElement或Collider时调用。
OnMouseUpAsButton()：只有当鼠标在同一个GUIElement或Collider按下，释放时调用。
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public class ObjectController : MonoBehaviour { private void OnMouseEnter()//当鼠标进入GUIElement或Collider时调用。（只调用一次）  { this.transform.localScale = new Vector3(1.3f, 1.3f, 1.3f);//物体放大1.3倍  } private void OnMouseExit()//鼠标离开  { this.transform.localScale = new Vector3(1f, 1f, 1f);//大小还原  this.transform.rotation = new Quaternion(0f,0f,0f,0f);//位置还原  } private void OnMouseOver()//鼠标悬停在GUIElement或Collider上时调用每一帧。  { this.</description>
    </item>
    
    <item>
      <title>MonoBehavior 常用方法</title>
      <link>/post/monobehavior-common_method-01/</link>
      <pubDate>Mon, 30 Jul 2018 15:04:16 +0800</pubDate>
      
      <guid>/post/monobehavior-common_method-01/</guid>
      <description>继承函数  继承自Object
 Destroy：物体销毁
 Instantiate：物体生成
 CompareTag：物体辨认
  继承自Component
 SendMessage：消息推送   自身函数 1.Invoke：延迟执行程序
 Invoke(string methodName, float time); InvokeRepeating(string methodName, float time, float repeatRate);   重复调用函数，重复间隔。
  IsInvoking(string methodName);   检测是否在继续调用。
  CanceInvoke();  CanceInvoke(string methodName);    清楚所有Invoke或针对某一函数。
    2.Coroutine：协同执行程序</description>
    </item>
    
    <item>
      <title>使用软件突发小技巧</title>
      <link>/post/use-skill/</link>
      <pubDate>Sun, 29 Jul 2018 16:55:57 +0800</pubDate>
      
      <guid>/post/use-skill/</guid>
      <description> 按住 shift ，在准备复制文字（或其它）的一头按鼠标左键，在另一头按下左键，即可选中两头中的所有文字（或其它）。
 </description>
    </item>
    
    <item>
      <title>C# _语言基础</title>
      <link>/post/c-sharp-notes-02/</link>
      <pubDate>Fri, 27 Jul 2018 08:18:12 +0800</pubDate>
      
      <guid>/post/c-sharp-notes-02/</guid>
      <description>值类型  包括自定义struct类型，enum枚举类型。值类型存储在内存的栈上面，在堆上面存储具体值。
值类型继承于System.ValueType，所有的类继承于System.Object。(Object是所有类型的基类)
/// 注释——为解释方法，类，空间&amp;hellip;进行说明
  struct——类型   用于打包封装小的数据集，可以(像class)建方法、事件&amp;hellip;。
  enum——类型   用于限定变量可能性。
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #namespace test { class Program { //角标从0开始，Mon=1，使强制从一开始  //enum Days : byte :short 转换类型  enum Days { Mon, Tues, Wenes, Thurs, Fri, Satur, Sun}//整数型  struct Perosn { public int age; private string name; internal string fname;//命名空间内可以访问  protected string lastName;//protected 只有继承于它，才能访问  } static void Main(string[] args) { Person perosn = new Perosn(); person.</description>
    </item>
    
    <item>
      <title>C# _基本操作</title>
      <link>/post/c-sharp-notes-01/</link>
      <pubDate>Tue, 24 Jul 2018 07:43:47 +0800</pubDate>
      
      <guid>/post/c-sharp-notes-01/</guid>
      <description>1.定义变量 必须声明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  //&amp;amp;&amp;amp;逻辑和||逻辑或 class Program { static void (string[] args) { int a=3; int b=0; if(a==3) { b=4; } else if(a==4) { b=5; } Console.ReadKey();//获取按键 暂停  } }   2.if() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  //随机抽卡 Random random = new Random(); int r = random.</description>
    </item>
    
    <item>
      <title>Monobehavior事件响应（1）</title>
      <link>/post/unity-script-01/</link>
      <pubDate>Sat, 21 Jul 2018 15:26:16 +0800</pubDate>
      
      <guid>/post/unity-script-01/</guid>
      <description>启动与刷新函数 启动  Reset() Awake()   在游戏开始之前初始化任何变量或游戏状态。
  Start   在任何Update方法之前，只调用一次。
 刷新  FixUpdate()   每个固定帧率帧都会调用此函数。 (用于物理效果)
  Update()   则每帧调用更新。(用于处理逻辑)
  LateUpdate()   每帧都会调用LateUpdate 。在调用所有Update函数后调用LateUpdate。
 交互函数 1.物理 Physic OnTriggerEnter()  当Collider进入trigger时调用
 OnTriggerStay()  当Collider停留trigger时每一帧被调用
 OnTriggerExit()  当Collider离开trigger时调用
 OnaCollisionEnter()  当collider/rigidbody触发另一个rigidbody/collider时被调用
 OnCollisionStay()  当collider/rigidbody触发另一个rigidbody/collider时，将会在每一帧被调用
 OnCollisionExit()  当collider/rigidbody停止触发另一个rigidbody/collider时被调用
 2.输入 Input 3.渲染 Rendering 4.对象与组件 OnEnable()  当对象变为可用或激活状态时此函数被调用</description>
    </item>
    
    <item>
      <title>Unity 注意事项</title>
      <link>/post/unity-notes-01/</link>
      <pubDate>Sat, 21 Jul 2018 10:38:10 +0800</pubDate>
      
      <guid>/post/unity-notes-01/</guid>
      <description> 疑难杂症——👇 一亿个注意: 1.Local和Global  Local是指的自身的坐标，Global指的是世界坐标。
假如一个物体没有父物体（即这个物体不是某个物体的子物体），或者父物体的坐标为（0，0，0）。这时候Local和Global的坐标是一样的。
假如有父物体，Local坐标是相对与父物体的坐标，而Global是指在空间中实际的坐标。
 2.Awake()和Start()  Awake()在游戏开始时自动调用，无论是否激活脚本组件都能被调用，一般用来创建变量。
Start()在Awake之后Update之前，一般用来初始化变量。
 3.Update()和FixUpdate()  Update()每一帧调用一次，一般用于非物理运动，如逻辑运算 。
Fixupdate()每隔固定时间调用一次，通过Edit-&amp;gt;Project Settings-&amp;gt;Time 进行设置，默认为20毫秒 ，一般用于物理运动。
 4.transform01translate0  transform是Gameobject的位置属性，translate是一个动作属性。
获取某个object的位置信息时就是transform，若是对其做动作，那就translate。
 5. </description>
    </item>
    
    <item>
      <title>Word Book</title>
      <link>/post/words-notes/</link>
      <pubDate>Fri, 20 Jul 2018 15:14:20 +0800</pubDate>
      
      <guid>/post/words-notes/</guid>
      <description>Word Note edit 编辑
assets 资源；资产
enable 允许；可用；使能够
disable 禁用/不可用
inspector 检视窗口
hierarchy 层级窗口
component 组件
variable 变量
scene 场景
analytics 分析
project 工程窗口
packages 包；封装；包装
static 静态
layer 层
layouts 布局
mesh 网格
renderer 渲染器
filter 过滤器
shader 着色器
collider 碰撞体
rigidbody 刚体
collider 碰撞体
trigger 触发
material 材质；材料
collision 碰撞
velocity 力；速度
eulerAngles 欧拉角
description 描述
transform 改变
translate 翻译；转化
rotation 旋转
position 位置；方位
scale 缩放；比例；规模
mass 质量</description>
    </item>
    
    <item>
      <title></title>
      <link>/404/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/404/</guid>
      <description>错误404：找不到页面 您尝试访问的页面似乎不存在。😟
如果你确定它存在，很可能它已被移动到一个新的链接! 您可以在主页上搜索它.</description>
    </item>
    
    <item>
      <title></title>
      <link>/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>So, Who Am I?</description>
    </item>
    
  </channel>
</rss>